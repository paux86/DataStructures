/** * A class that provides methods for sorting a stack of * Comparable objects, placing the smallest at the top of the stack. * * @author Matt Brierley * @version 02/18/2019 */import java.util.*;public class SortStack<T extends Comparable<? super T>>{    private Stack<T> stack;    public SortStack()    {        this.stack = new Stack<>();    }    /**     * Sorts a stack.     *     * @return a sorted stack     */    public Stack<T> sort()    {        // TODO PROJECT #5 Part1 - done        // this.stack represents the original stack        Stack<T> destination = new Stack<>();        Stack<T> temp = new Stack<>();        //Push top element of original stack to destination        System.out.printf("Push %s from original to destination\n", destination.push(this.stack.pop()));        while(!this.stack.isEmpty())        {            T topOfOriginal = this.stack.pop();            //if topOfOriginal is smaller than top of destination, push topOfOriginal to destination            if(destination.isEmpty() || topOfOriginal.compareTo(destination.peek()) <= 0)            {                System.out.printf("Push %s to destination\n", destination.push(topOfOriginal));            }            else            {                System.out.print("Moving entries from destination to temp\n");                //if topOfOriginal is larger than top of destination, pop each smaller element of destination and push it to temp                while(!destination.isEmpty() && topOfOriginal.compareTo(destination.peek()) > 0)                {                    System.out.printf("--> push %s from destination to temp\n", temp.push(destination.pop()));                }                //push topOfOriginal to destination                System.out.printf("Push %s to destination\n", destination.push(topOfOriginal));                //pop all of temp and push each to destination                System.out.print("Moving entries from temp to destination\n");                while(!temp.isEmpty())                {                    System.out.printf("--> push %s from temp to destination\n", destination.push(temp.pop()));                }            }        }        return destination;    }    /**     * Sorts a stack. (revised version)     *     * @return a sorted stack     */    public Stack<T> sortRevised()    {        // TODO PROJECT #5 Part2 - done        // this.stack represents the original stack        Stack<T> destination = new Stack<>();        Stack<T> temp = new Stack<>();        //pop the top element of this.stack to destination        System.out.printf("--> push %s from original to destination\n", destination.push(this.stack.pop()));        while(!this.stack.isEmpty())        {            T topOfOriginal = this.stack.pop();            //if topOfOriginal < destination.peek(), while temp.peek() > topOfOriginal -> pop/push temp to destination            if(topOfOriginal.compareTo(destination.peek()) < 0)            {                System.out.print("Moving entries from temp to destination\n");                while(!temp.isEmpty() && topOfOriginal.compareTo(temp.peek()) < 0)                {                    System.out.printf("--> push %s from temp to destination\n", destination.push(temp.pop()));                }            }            //if topOfOriginal > destination.peek(), while destination.peek() < top ofOriginal -> push/pop destination to temp            else if(topOfOriginal.compareTo(destination.peek()) > 0)            {                System.out.print("Moving entries from destination to temp\n");                while(!destination.isEmpty() && topOfOriginal.compareTo(destination.peek()) > 0)                {                    System.out.printf("--> push %s from destination to temp\n", temp.push(destination.pop()));                }            }            //after shifting elements, push topOfOriginal to destination            System.out.printf("push %s from original to destination\n", destination.push(topOfOriginal));        }        //push/pop remaining elements of temp to destination        System.out.print("Moving any remaining entries from temp to destination\n");        while(!temp.isEmpty())        {            System.out.printf("--> push %s from temp to destination\n", destination.push(temp.pop()));        }        return destination;    }    public void setStack(T... elements)    {        this.stack.clear();        System.out.println("Setting the original stack to:");        for (int i = 0; i < elements.length; i++)        {            this.stack.push(elements[i]);            System.out.print(elements[i] + " ");        }        System.out.println();    }    public static void main(String[] args)    {        SortStack sc = new SortStack();        sc.setStack("03", "09", "01", "04", "06", "05", "07", "08", "00", "02");        System.out.println("\n***Calling sort method***");        Stack<String> sortedStack = sc.sort();        System.out.println("\nStack should be sorted (with sort()) ....");        while (!sortedStack.isEmpty())            System.out.print(sortedStack.pop() + " ");        System.out.println();        System.out.println("\n===================================");        System.out.println("\nTesting the revised method");        sc.setStack("03", "09", "01", "04", "06", "05", "07", "08", "00", "02");        System.out.println("\n***Calling sortRevised method***");        sortedStack = sc.sortRevised();        System.out.println("\nStack should be sorted (with sortRevised()) ....");        while (!sortedStack.isEmpty())            System.out.print(sortedStack.pop() + " ");        System.out.println();    } // end main} // end SortStack