import java.util.*;/** * A class that creates a minimum spanning tree * for a given graph * The graph is represented by adjacency matrix * * @author atb * @version 4/30/2019 */public class WhichRoadsCanBeClosed{    // The matrix below represents the graph from the example provided in the lab description    // The instructor used this hardcoded matrix for testing,    // your code however must generate the matrix randomly//    private int[][] adjMatrix = {{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},//            {0, 0, 0, 3, 1, 0, 0, 0, 0, 0, 2},//            {0, 0, 0, 4, 0, 0, 10, 0, 0, 0, 0},//            {0, 3, 4, 0, 3, 5, 0, 0, 0, 0, 0},//            {0, 1, 0, 3, 0, 2, 0, 0, 0, 0, 0},//            {0, 0, 0, 5, 2, 0, 6, 0, 1, 0, 0},//            {0, 0, 10, 0, 0, 6, 0, 9, 10, 0, 0},//            {0, 0, 0, 0, 0, 0, 9, 0, 0, 0, 0},//            {0, 0, 0, 0, 0, 1, 10, 0, 0, 8, 0},//            {0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 10},//            {0, 2, 0, 0, 0, 0, 0, 0, 0, 10, 0}};    private int[][] adjMatrix;    private int[][] minimumSpanningTree;    private int numberOfNodes;    final int GRAYED_OUT = -1;    final int UNMARK_FOR_CHECKING = 0;    final int PERCENT100 = 100;    final int MAX_WEIGHT = 25;    public WhichRoadsCanBeClosed(int numberOfNodes, int probability)    {        //TODO Lab14b #1.1 - done        this.numberOfNodes = numberOfNodes;        this.adjMatrix = new int[this.numberOfNodes + 1][this.numberOfNodes + 1];        this.minimumSpanningTree = new int[this.numberOfNodes + 1][this.numberOfNodes + 1];        Random random = new Random(61);        for(int row = 1; row < this.numberOfNodes + 1; row++)        {            for(int col = row+1; col < this.numberOfNodes + 1; col++)            {                if(random.nextInt(PERCENT100 + 1) <= probability)                {                    int val = random.nextInt(MAX_WEIGHT)+1;                    this.adjMatrix[row][col] = val;                    this.adjMatrix[col][row] = val;                }            }        }    }    public void displayRoadsThatCanBeClosed()    {        System.out.println("\nThe following roads can be closed:");        //TODO Lab14b #1.4 - done        for(int row = 1; row <= this.numberOfNodes + 1; row++)        {            for(int col = row+1; col <= this.numberOfNodes; col++)            {                if(this.adjMatrix[row][col] > this.minimumSpanningTree[row][col])                {                    System.out.printf("%d ==== %d\n",row,col);                }            }        }    }    public boolean isConnected()    {        //TODO Lab14b #1.5 - done        // utilize breath-first-traversal algorithm        //each row is a vertex, and their values are the [col] vertices they connect to        Queue<Integer> vertexQueue = new LinkedList<>();        //array of rows that have been visited        boolean[] visited = new boolean[this.numberOfNodes + 1];        int firstVertex = 1;        vertexQueue.offer(firstVertex);        visited[firstVertex] = true;        while(!vertexQueue.isEmpty())        {            int curVertex = vertexQueue.poll();            //System.out.println("Viewing row " + curVertex);            for(int col = 1; col < this.numberOfNodes + 1; col++)            {                int colValue = this.adjMatrix[curVertex][col];                //System.out.printf("Checking [ %d, %d ]\n", col,colValue);                if(colValue != 0 && !visited[col])                {                    visited[col] = true;                    vertexQueue.offer(col);                    //System.out.println("Visisted " + col);                }            }        }        boolean connected = true;        for(int i = 1; i < visited.length; i++)        {            if(!visited[i])            {                connected = false;            }            //System.out.printf("Visited row[%d] : %b\n", i, visited[i]);        }        return connected;    }    public boolean minimumSpanningTreeCheckForCycle()    {        boolean[] visited = new boolean[this.numberOfNodes + 1];        return hasCycle(this.minimumSpanningTree, 1, visited);    }    public boolean connectedGraphCheckForCycle()    {        boolean[] visited = new boolean[this.numberOfNodes + 1];        return hasCycle(this.adjMatrix, 1, visited);    }    private boolean hasCycle(int[][] graphToCheck, int start, boolean[] visited)    {        //TODO Lab14b #1.6 - done        visited[start] = true;        for (int j = start + 1; j <= this.numberOfNodes; j++)        {            // if start and j are connected return true if either j was visited or recursive call starting with j returns true            if(graphToCheck[start][j] != 0)            {                if(visited[j] || hasCycle(graphToCheck, j, visited))                {                    return true;                }            }        }        return false;    }    public void calculateMinimumSpanningTree()    {        //TODO Lab14b #1.3 - done        // utilize findSmallestInMarkedRows method        //mark first now and column        this.adjMatrix[0][1] = GRAYED_OUT;        this.adjMatrix[1][0] = GRAYED_OUT;        SmallestWithIndexes smallest = this.findSmallestInMarkedRows();        //if all columns greyed out, smallest will return 0 for row/col, and loop should terminate        while(smallest.column != 0)        {            //grey out row and mark row[col]            this.adjMatrix[0][smallest.column] = GRAYED_OUT;            this.adjMatrix[smallest.column][0] = GRAYED_OUT;            this.minimumSpanningTree[smallest.row][smallest.column] = smallest.value;            this.minimumSpanningTree[smallest.column][smallest.row] = smallest.value;            smallest = this.findSmallestInMarkedRows();        }    }    private SmallestWithIndexes findSmallestInMarkedRows()    {        //TODO Lab14b #1.2 - done        int smallest = MAX_WEIGHT;        int row = 0;        int col = 0;        //check each row        for(int r = 1; r <= this.numberOfNodes; r++)        {            //if row is checked (greyed out), check each column            if(this.adjMatrix[r][0] == GRAYED_OUT)            {                boolean comparisonMade = false;                for(int c = 1; c <= this.numberOfNodes; c++)                {                    //if column is not greyed out or unmarked, compare value with current smallest                    if(this.adjMatrix[0][c] != GRAYED_OUT && this.adjMatrix[r][c] != UNMARK_FOR_CHECKING)                    {                        if(this.adjMatrix[r][c] < smallest)                        {                            row = r;                            col = c;                            smallest = this.adjMatrix[r][c];                        }                        comparisonMade = true;                    }                }                //if no comparisons were made in a row (all columns greyed) then do not continue to check it                if(!comparisonMade)                {                    this.adjMatrix[r][0] = UNMARK_FOR_CHECKING;                }            }        }        //System.out.println("row= " + row + "; col= " + col + "; smallest= " + smallest);        return new SmallestWithIndexes(row, col, smallest);    }    public void displayGraph()    {        System.out.println("***** GENERATED GRAPH *****");        displayMatrix(this.adjMatrix);    }    public void displayMinimumSpanningTree()    {        System.out.println("\n\n***** Computed MINIMUM SPANNING TREE for the above graph *****");        displayMatrix(this.minimumSpanningTree);    }    private void displayMatrix(int[][] matrix)    {        System.out.print("     ");        for (int c = 1; c <= this.numberOfNodes; c++)        {            System.out.printf("[%1$2d]", c);        }        System.out.println();        for (int r = 1; r <= this.numberOfNodes; r++)        {            System.out.printf("[%1$2d]", r);            for (int c = 1; c <= this.numberOfNodes; c++)            {                if (matrix[r][c] > 0)                    System.out.printf("%1$4d", matrix[r][c]);                else                    System.out.printf("%1$4s", " ");            }            System.out.println();        }    }    private void displayMSTinLevelOrder()    {        System.out.println("\n\n***** Computed MINIMUM SPANNING TREE in Level-order *****");        //TODO Lab14b #1.7        //each row is a vertex, and their values are the [col] vertices they connect to        Queue<Integer> vertexQueue = new LinkedList<>();        //array of rows that have been visited        boolean[] visited = new boolean[this.numberOfNodes + 1];        int firstVertex = 1;        vertexQueue.offer(firstVertex);        visited[firstVertex] = true;        int level = 0;        while(!vertexQueue.isEmpty())        {            System.out.printf("Level %d: ",++level);            int levelSize = vertexQueue.size();            while(levelSize > 0)            {                int curVertex = vertexQueue.poll();                System.out.print(curVertex + " ");                for(int col = 1; col < this.numberOfNodes + 1; col++)                {                    int colValue = this.minimumSpanningTree[curVertex][col];                    if(colValue != 0 && !visited[col])                    {                        visited[col] = true;                        vertexQueue.offer(col);                    }                }                levelSize--;            }            System.out.println();        }    }    public static void main(String[] args)    {        System.out.println("How many nodes in your graph?");        Scanner scan = new Scanner(System.in);        int numberOfNodes = scan.nextInt();        System.out.println("Probability of edge? (type 70 for 70%)");        int probability = scan.nextInt();        WhichRoadsCanBeClosed graph = new WhichRoadsCanBeClosed(numberOfNodes, probability);        graph.displayGraph();        if (graph.isConnected())        {            if (graph.connectedGraphCheckForCycle())                System.out.println("\nThe graph has cycles.");            else                System.out.println("\nThe graph is acyclic.");            graph.calculateMinimumSpanningTree();            graph.displayMinimumSpanningTree();            graph.displayRoadsThatCanBeClosed();            if (graph.minimumSpanningTreeCheckForCycle())                System.out.println("\nThe minimum spanning tree has cycles.");            else                System.out.println("\nThe minimum spanning tree is acyclic.");            graph.displayMSTinLevelOrder();        }        else            System.out.println("The graph is not connected, the minimum spanning tree will not be calculated");    } // end main    private class SmallestWithIndexes    {        private int row;        private int column;        private int value;        public SmallestWithIndexes(int row, int column, int value)        {            this.row = row;            this.column = column;            this.value = value;        }    }}